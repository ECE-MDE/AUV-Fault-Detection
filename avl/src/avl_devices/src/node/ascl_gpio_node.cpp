//==============================================================================
// Autonomous Vehicle Library
//
// Description: ROS node to publish pressure, temperature, and motor RPM from
//              the GPIO board designed for the 690 AUV. See:
//
//     https://ascl.ece.vt.edu/trac/690/browser#690/design/electronics/gpio
//
// Servers:     None
//
// Clients:     None
//
// Publishers:  device/pressure (std_msgs/Float64)
//              device/temperature (std_msgs/Float64)
//              device/rpm (std_msgs/Float64)
//
// Subscribers: None
//==============================================================================

// Core utility
#include <avl_core/node.h>
#include <avl_asio/serial_port.h>
#include <avl_comms/packet_handler.h>
#include <avl_core/util/string.h>
#include <avl_core/util/file.h>

// ROS message service includes
#include <std_msgs/Float64.h>
#include <std_srvs/Trigger.h>

// Boost circular buffer for storing pressure values for zeroing
#include <boost/circular_buffer.hpp>

// YAML C++
#include <yaml-cpp/yaml.h>

// File output stream
#include <fstream>

//==============================================================================
//                              NODE DEFINITION
//==============================================================================

class AsclGpioNode : public Node
{

public:

    //--------------------------------------------------------------------------
    // Name:        AsclGpioNode constructor
    //--------------------------------------------------------------------------
    AsclGpioNode(int argc, char **argv) : Node(argc, argv)
    {

    }

private:

    // Serial port instance
    SerialPort serial;

    // Publishers for pressure, temperature, and RPM messages
    ros::Publisher pressure_pub;
    ros::Publisher temperature_pub;
    ros::Publisher rpm_pub;

    // Service server for pressure sensor zeroing
    ros::ServiceServer zero_pressure_server;

    // Buffer to store pressure data for zeroing
    boost::circular_buffer<double> pressure_value_buffer;

    // Pressure measurement offset generated by zeroing the pressure. This value
    // is subtracted from every pressure measurement
    double pressure_offset = 0.0;

    PacketHandler packet_handler;

private:

    //--------------------------------------------------------------------------
    // Name:        read_callback
    // Description: Called when the read match condition is met.
    // Arguments:   - data: data read by match condition
    //--------------------------------------------------------------------------
    void read_callback(std::vector<uint8_t> data)
    {

        // Form a string from the vector of bytes
        std::string line(data.begin(), data.end());
        avl::strip(line, '\r');
        avl::strip(line, '\n');

        // Split the space delimited GPIO message
        std::vector<std::string> split_line = avl::split(line, " ");

        try
        {

            // Parse the sensor indicator character and the measurement value
            // from the split string. The first entry is a character indicating
            // which sensor the measurement is from. The last entry is the
            // measurement value. There are a number of spaces between the
            // character and the value different for each sensor for some
            // reason, but we don't care about them.
            char sensor_char = split_line.at(0)[0];
            double sensor_value = std::stod(split_line.back());

            // Decide what to do based on what sensor the message is from
            switch (sensor_char)
            {

                // A `p` indicates a pressure message. The pressure value is the
                // pressure divided by the pressure precision, so multiply by
                // the precision to get the pressure
                case 'p':
                {

                    if(get_param<bool>("~enable_pressure"))
                    {

                        // Calculate the pressure from the precision
                        double pressure = sensor_value*get_param<double>("~pressure_precision");

                        // Remove the pressure offset from the pressure value
                        pressure -= pressure_offset;

                        // Add the pressure value to the buffer for pressure
                        // zeroing
                        pressure_value_buffer.push_back(pressure);

                        // Create, publish, and log the pressure message
                        std_msgs::Float64 pressure_msg;
                        pressure_msg.data = pressure;
                        pressure_pub.publish(pressure_msg);
                        log_data("[pressure] %.4f", pressure);

                    }

                    break;

                }

                // A `t` indicates a temperature message. The temperature value
                // is the temperature divided by the temperature precision, so
                // multiply by the precision to get the pressure
                case 't':
                {

                    if(get_param<bool>("~enable_temperature"))
                    {

                        // Create, publish, and log the temperature message
                        std_msgs::Float64 temperature_msg;
                        temperature_msg.data = sensor_value*get_param<double>("~temperature_precision");
                        temperature_pub.publish(temperature_msg);
                        log_data("[temperature] %.4f", temperature_msg.data);

                    }

                    break;

                }

                // An `n` indicates an encoder message. The encoder value is the
                // rotation rate in Hz divided by the encoder precision, so
                // multiply by the precision to get the pressure
                case 'n':
                {

                    if(get_param<bool>("~enable_rpm"))
                    {

                        // Calculate the RPM from the encoder rotation rate
                        double encoder_hz = sensor_value*get_param<double>("~encoder_precision");
                        double encoder_rpm = round((encoder_hz / get_param<double>("~encoder_resolution"))*60);

                        // Create, publish, and log the RPM message
                        std_msgs::Float64 rpm_msg;
                        rpm_msg.data = encoder_rpm;
                        rpm_pub.publish(rpm_msg);
                        log_data("[rpm] %.4f", rpm_msg.data);

                    }

                    break;

                }

                default:
                {
                    log_warning("received incorrectly formatted GPIO message (%s)", line.c_str());
                }

            }

        }
        catch (const std::exception& ex)
        {
            log_warning("failed to parse GPIO message (%s)", ex.what());
        }

    }

    //--------------------------------------------------------------------------
    // Name:        read_calibration_file
    // Description: Reads in the YAML formatted calibration config file at the
    //              given filepath and saves the pressure offset value from it.
    // Arguments:   - filepath: path to the calibration file
    //--------------------------------------------------------------------------
    void read_calibration_file(std::string filepath)
    {

        YAML::Node calibration_file;

        if (avl::file_exists(filepath))
        {
            calibration_file = YAML::LoadFile(filepath);
            pressure_offset = calibration_file["pressure_offset"].as<double>();
        }
        else
            log_warning("no calibration file found at " + filepath + ", using offset of 0.0");

    }

    //--------------------------------------------------------------------------
    // Name:        write_calibration_file
    // Description: Writes a YAML formatted pressure offset calibration config
    //              file to the given filepath.
    // Arguments:   - filepath: filepath to write configuration file to
    //--------------------------------------------------------------------------
    void write_calibration_file(std::string filepath)
    {

        // Calibration file header
        std::string calibration_file_header =
            "#===============================================================================\n"
            "# Autonomous Vehicle Library \n"
            "# \n"
            "# DO NOT MODIFY! Automatically generated from the ASCL GPIO node! \n"
            "# \n"
            "# PURPOSE: Pressure offset calibration file generated by the ASCL GPIO node"
            "#===============================================================================\n\n";

        YAML::Node calibration_file;
        calibration_file["pressure_offset"] = pressure_offset;

        std::ofstream fout(filepath);
        fout  << calibration_file_header
              << calibration_file
              << std::endl;
        fout.close();

    }

    //--------------------------------------------------------------------------
    // Name:        zero_pressure_srv_callback
    // Description: Called when a zero_pressure service is requested.
    //              Sets an average of the current pressure to zero pressure.
    // Arguments:   - req: request received on the service
    //              - res: response to the service request
    // Returns:     True if service succeeded, false if it failed and was not
    //              responded to.
    //--------------------------------------------------------------------------
    bool zero_pressure_srv_callback(std_srvs::Trigger::Request& req,
                                    std_srvs::Trigger::Response& res)
    {
        tare_pressure();
        return true;
    }

    // //--------------------------------------------------------------------------
    // // Name:        command_callback
    // // Description: Called when a command packet is received on the command
    // //              topic.
    // // Arguments:   - command: command packet received on the command topic
    // // Returns:     Command response string.
    // //--------------------------------------------------------------------------
    // bool command_callback(Packet command, Packet& response)
    // {
    //
    //     // Handle ACTION packets with a TARE_PRESSURE field
    //     if (command.get_descriptor() == ACTION_PACKET_DESC &&
    //         command.has_field(ACTION_TARE_PRESSURE_DESC))
    //     {
    //         tare_pressure();
    //         std::string response_string = "success [ascl_gpio_node] (pressure tare complete)";
    //         response.add_field(RESPONSE_PACKET_DESCRIPTOR(ACTION_PACKET_DESC));
    //         response.add_field(RESPONSE_FIELD_DESCRIPTOR(ACTION_TARE_PRESSURE_DESC));
    //         std::vector<uint8_t> response_vector(response_string.begin(), response_string.end());
    //         response.add_field(RESPONSE_DATA(response_vector));
    //         return true;
    //     }
    //
    //     return false;
    //
    // }

    //--------------------------------------------------------------------------
    // Name:        tare_pressure
    // Description: Tares the pressure sensor by calculating the average
    //              pressure and saving that as the pressure offset, which is
    //              subtracted from all pressure data. The offset value is also
    //              saved to the calibration file.
    //--------------------------------------------------------------------------
    void tare_pressure()
    {

        if (pressure_value_buffer.size() > 0)
        {

            log_info("starting pressure tare with %d pressure points...", pressure_value_buffer.size());

            // Loop through the values in the pressure value buffer and take the
            // average
            float pressure_value_average = 0.0;
            for (float value : pressure_value_buffer)
                pressure_value_average += value;
            pressure_value_average = pressure_value_average / pressure_value_buffer.size();

            // Add the pressure value average to the pressure offset. We do this
            // so that we can use already gathered depth points instead of
            // setting the pressure offset to zero and waiting for new points
            pressure_offset += pressure_value_average;

            // Write the pressure offset calibration file to save the new value
            write_calibration_file(get_param<std::string>("~calibration_filepath"));

            // Clear the pressure value buffer so that the any old points with
            // the old depth offset are removed
            pressure_value_buffer.clear();

            log_info("pressure tare complete");

        }
        else
        {
            log_warning("ignored zero pressure service call, no pressure values in buffer");
        }

    }

    //--------------------------------------------------------------------------
    // Name:        init
    // Description: Initializes the node. Called when the node is started.
    //--------------------------------------------------------------------------
    void init()
    {

        // Log the data headers
        log_data("[pressure] pressure");
        log_data("[pressure] PSI");
        log_data("[temperature] temperature");
        log_data("[temperature] C");
        log_data("[rpm] RPM");
        log_data("[rpm] RPM");

        // Set up the publishers for pressure, temperature, and RPM messages
        pressure_pub    = node_handle->advertise<std_msgs::Float64>("device/pressure", 1);
        temperature_pub = node_handle->advertise<std_msgs::Float64>("device/temperature", 1);
        rpm_pub         = node_handle->advertise<std_msgs::Float64>("device/rpm", 1);

        // Set up the pressure zeroing server
        zero_pressure_server = node_handle->advertiseService("device/zero_pressure",
            &AsclGpioNode::zero_pressure_srv_callback, this);

        // Set the capacity of the depth values ring buffer from the config
        // file
        pressure_value_buffer.set_capacity(get_param<int>("~max_pressure_zeroing_points"));

        // Read in the pressure offset value from the calibration config file
        read_calibration_file(get_param<std::string>("~calibration_filepath"));

        // Configure and open the serial port. The GPIO board publishes messages
        // ending in a newline, so set the match condition to a newline
        serial.set_match(Match("\n", &AsclGpioNode::read_callback, this));
        serial.set_read_timeout(get_param<int>("~serial/read_timeout"));
        serial.open(get_param<std::string>("~serial/port_name"),
                    get_param<int>("~serial/baudrate"));

        // Enable the node's command handler for handling ACTION packets with a
        // TARE_PRESSURE field
        // command_handler->init(&AsclGpioNode::command_callback, this);

    }

    //--------------------------------------------------------------------------
    // Name:        run
    // Description: Main node loop. Called after the node is initialized.
    //--------------------------------------------------------------------------
    void run()
    {
        ros::Rate spin_rate(1000);
        while(ros::ok())
        {
            serial.spin_once();
            ros::spinOnce();
            spin_rate.sleep();
        }
    }

};

//==============================================================================
//                                  MAIN
//==============================================================================
int main(int argc, char **argv)
{
    AsclGpioNode node(argc, argv);
    node.start();
    return 0;
}
